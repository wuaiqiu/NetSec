				ruby(二)

一.类与对象
	
	(1)创建类
		类总是以关键字 class 开始，后跟类的名称。类名的首字母应该大写

		class Customer
			.....
		end

	(2)Ruby 类中的变量
		
		注意：在 Ruby 中，您可以通过在变量或常量前面放置 #{ expr } 字符，

	来访问任何变量或常量的值。

		a.局部变量：局部变量是在方法中定义的变量。局部变量在方法外是不可用的。

	局部变量以小写字母或 _ 开始。
		
	
		b.实例变量：实例变量可以跨任何特定的实例或对象中的方法使用。这意味着，

	实例变量可以从对象到对象的改变。实例变量在变量名之前放置符号（@）。未初始化的

	实例变量的值为 nil

	========================================================================	
	
		class Customer
		   def initialize(id, name, addr)
		      @cust_id=id
		      @cust_name=name
		      @cust_addr=addr
		   end
	   
		  def display_details()
		      puts "Customer id #{@cust_id}"
		      puts "Customer name #{@cust_name}"
		      puts "Customer address #{@cust_addr}"
		    end
		end
	========================================================================	

		c.类变量：类变量可以跨不同的对象使用。类变量属于类，且是类的一个属性。

	类变量在变量名之前放置符号（@@）。必须初始化后才能在方法定义中使用，类变量在定

	义它的类或模块的子类或子模块中可共享使用。
	
	========================================================================	
		class Customer
		   @@no_of_customers=0
		    def total_no_of_customers()
		       @@no_of_customers += 1
		       puts "Total number of customers: #{@@no_of_customers}"
		    end
		end
	=====================================================================

		d.全局变量：类变量不能跨类使用。如果您想要有一个可以跨类使用的变量，

	您需要定义全局变量。全局变量总是以美元符号（$）开始。未初始化的实例变量的

	值为 nil	
	
	=====================================================================
		$global_variable = 10
		class Class1
			  def print_global
			      puts "全局变量在 Class1 中输出为 #{$global_variable}"
			  end
		end

		class Class2
			  def print_global
			      puts "全局变量在 Class2 中输出为 #{$global_variable}"
			  end
		end
	 =====================================================================
	
		e.Ruby常量以大写字母开头。定义在类或模块内的常量可以从类或模块的内部访问，

	定义在类或模块外的常量可以被全局访问。

	======================================================================
		class Example
		   VAR1 = 100
		   VAR2 = 200
		   def show
		       puts "第一个常量的值为 #{VAR1}"
		       puts "第二个常量的值为 #{VAR2}"
		   end
		end
	=======================================================================
	

	(3)创建对象
		
		使用类的方法 new 创建对象。
		
		cust1 = Customer. new
		cust2 = Customer. new

		构造方法
		
		class Customer
			   @@no_of_customers=0
			   def initialize(id, name, addr)
			      @cust_id=id
			      @cust_name=name
		      	      @cust_addr=addr
			   end	
		end

	(4)Ruby 类中的成员函数
		
		类中的每个方法是以关键字 def 开始，方法名总是以小写字母开头
		
		class Sample
		   def function
		      statement 1
		      statement 2
		   end
		end


	(5)Ruby 伪变量
		
		它们是特殊的变量，有着局部变量的外观，但行为却像常量。您不能给

	这些变量赋任何值。
		
		self: 当前方法的接收器对象。
		true: 代表 true 的值。
		false: 代表 false 的值。
		nil: 代表 undefined 的值。
		__FILE__: 当前源文件的名称。
		__LINE__: 当前行在源文件中的编号。
		

	(7)类方法

	当方法定义在类的外部，方法默认标记为 private。另一方面，如果方法定义在类中的，

	则默认标记为 public。

	===================================================================

	class Accounts
	   def Accounts.return_date
	   	puts "ok"
	   end
	end
	
	Accounts.return_date
	>ok
	==================================================================

	(8)访问器(getter) & 设置器(setter)方法
		
	由于(getter与setter)两种方法非常常用，Ruby 定义了
		 attr_accessor :variable_name
		 attr_reader :variable_name
		 attr_writer :variable_name 

	==================================================================
	(9)to_s 方法
	
	class Box
	   # 构造器方法
	   def initialize(w,h)
      		@width, @height = w, h
	   end
	   # 定义 to_s 方法
	   def to_s
	      "(w:#@width,h:#@height)"  # 对象的字符串格式
	   end
	end
 

	# 创建对象
	box = Box.new(10, 20)
	# 自动调用 to_s 方法
	puts "String representation of box is : #{box}"

	>>String representation of box is : (w:10,h:20)

	==================================================================
	
	(10)访问控制

	Ruby 为您提供了三个级别的实例方法保护，分别是 public、private 或 protected。
	
	Ruby不在实例和类变量上应用任何访问控制。

	class Box
  	 
	# 构造器方法
  	 def initialize(w,h)
	      @width, @height = w, h
	 end
 
  	 # 实例方法默认是 public 的
  	 def getArea
    	  	getWidth() * getHeight
  	 end
 
  	# 定义 private 的访问器方法
   	def getWidth
      		@width
   	end
 
   	private :getWidth
 
      end
	
	==================================================================

	(11)类的继承

	class Box
  		....
	end
 
	# 定义子类
	class BigBox < Box
 		......
	end

	==================================================================

	(12)方法重载
	
	class Box
 	  def getArea
     		puts "Box"
   	  end
	end
 
	class BigBox < Box
   	  def getArea
      		puts "BigBox"
   	  end
	end
 
	==================================================================
	
二.语句
	
	(1)if..else

	=====================================================================
		x=1
		if x > 2
		   puts "x 大于 2"
		elsif x <= 2 and x!=0
		   puts "x 是 1"
		else
		   puts "无法得知 x 的值"
		end
	=====================================================================
	
		$a=1
		print "debug\n" if $a
	
	=====================================================================

	
	(2)case
		
	=====================================================================
		$age =  5
		case $age
		when 0 .. 2
		    puts "婴儿"
		when 3 .. 6
		    puts "小孩"
		when 7 .. 12
		    puts "child"
		when 13 .. 18
		    puts "少年"
		else
		    puts "其他年龄段的"
		end
	=====================================================================

	(3)while
		
	=====================================================================
		$i = 0
		$num = 5
 
		while $i < $num  do
		   puts("在循环语句中 i = #$i" )
		   $i +=1
		end
	=====================================================================

		$i = 0
		$num = 5
		begin
		   puts("在循环语句中 i = #$i" )
		   $i +=1
		end while $i < $num
	=====================================================================
	
	(4)for
	
	=====================================================================
	for i in 0..5
	   puts "局部变量的值为 #{i}"
	end

	(0..5).each do |i|
	   puts "局部变量的值为 #{i}"
	end
	=====================================================================
	
	(5)break,next,redo

	=====================================================================
	for i in 0..5
	   if i > 2 then
	      break
	   end
	   puts "局部变量的值为 #{i}"
	end
	
	>局部变量的值为 0
	>局部变量的值为 1
	>局部变量的值为 2
	=====================================================================

	for i in 0..5
	   if i < 2 then
	      next
	   end
	   puts "局部变量的值为 #{i}"
	end
	
	>局部变量的值为 2
	>局部变量的值为 3
	>局部变量的值为 4
	>局部变量的值为 5

	=====================================================================

	for i in 0..5
	   if i < 2 then
	      puts "局部变量的值为 #{i}"
	      redo
	   end
	end	
	
	>局部变量的值为 0
	>局部变量的值为 0
	>...

三.ruby方法

	(1)简单的方法
	def method_name 
	   expr..
	end
	
	(2)接受参数的方法
	def method_name (var1, var2)
	   expr..
	end
	
	(3)参数设置默认值
	def method_name (var1=value1, var2=value2)
	   expr..
	end

	(4)调用方法
	method_name
	method_name 25, 30

	(6)return 语句,默认ruby方法都有返回值，默认返回最后一个变量
	
	def test
	   i = 100
	   j = 200
	   k = 300
	return i, j, k
	end
	
	var = test
	>[100,200,300]
	

	(7)可变数量的参数
	
	def sample (*test)
	   puts "参数个数为 #{test.length}"
	   for i in 0...test.length
	      puts "参数值为 #{test[i]}"
	   end
	end
	sample "Zara", "6", "F"
	sample "Mac", "36", "M", "MCA"

	(8)alias 语句
	这个语句用于为方法或全局变量起别名。为编号的全局变量（$1, $2,...）起别名是被禁止的。
		
	alias 方法名 方法名
	alias 全局变量 全局变量
	
	(9)undef 语句
	这个语句用于取消方法定义。undef 不能出现在方法主体内。
	under bar

四.ruby块
	
	块总是从与其具有相同名称的函数调用。这意味着如果您的块名称为 test，那么您要使用函数 test 

	来调用这个块。您可以使用 yield 语句来调用块。

	=====================================================================
	def test
	   puts "在 test 方法内"
	   yield
	   puts "你又回到了 test 方法内"
	   yield
	end
	

	test {puts "你在块内"}
	>在 test 方法内
	>你在块内
	>你又回到了 test 方法内
	>你在块内
	=====================================================================

	传递带有参数的 yield 语句
	
	def test
	   yield 5
	   puts "在 test 方法内"
	   yield 100
	end
	
	test {|i| puts "你在块 #{i} 内"}
	>你在块 5 内
	>在 test 方法内
	>你在块 100 内
	=====================================================================

	在块中，您可以在两个竖线之间放置一个变量来接受参数。因此，在上面的代码中，yield 5 
	语句向 test 块传递值 5 作为参数。
	
	test {|i| puts "你在块 #{i} 内"}

	如果您想要传递多个参数，那么 yield 语句如下所示：
	yield a, b
	test {|a, b| statement}


五.ruby模块

	模块（Module）定义了一个命名空间，相当于一个沙盒
	
	模块类似与类，但有一下不同：
		(1)模块不能实例化
		(2)模块没有子类
		(3)模块只能被另一个模块定义

	=====================================================================
	
	module Identifie
	   statement1
	   statement2
	   ...........
	end
	=====================================================================
	
	module也可以包含类，但调用时需要这样使用 模块名::类名.new
	
	module Human
		class Boy
			def say
				puts "cool"
			end
		end
	end
	
	obj=Human::Boy.new
	obj.say

	=========================================================================
	Ruby require 语句
	require 语句类似于 C 和 C++ 中的 include 语句以及 Java 中的 import 语句。如果一个
	第三方的程序想要使用任何已定义的模块，则可以简单地使用 Ruby require 语句来加载模块文件：
	
	$LOAD_PATH << '.'
 
	require 'trig.rb'
	require 'moral'

 	$LOAD_PATH << '.' 让 Ruby 知道必须在当前目录中搜索被引用的文件。
	
	=====================================================================
	Ruby include 语句
	您可以在类中嵌入模块。为了在类中嵌入模块，您可以在类中使用 include 语句：
	module Week
	  ....
	end
	
	class Decade
	include Week
	  ....
	end


	 在使用require时，请求加载的内容放到引号里，而inclue不是用引号
	
	=====================================================================
	Ruby 中的 Mixins
	Ruby 没有真正实现多重继承机制，而是采用成为mixin技术作为替代品。将模块include
	到类定义中，模块中的方法就mix进了类中。
	
	module A
	   def a1
	   end
	   def a2
	   end
	end
	module B
	   def b1
	   end
	   def b2
	   end
	end
 
	class Sample
	include A
	include B
		def s1
	        end
	end
