				ruby(二)

一.类与对象
	
	(1)创建类
		类总是以关键字 class 开始，后跟类的名称。类名的首字母应该大写

		class Customer
			.....
		end

	(2)Ruby 类中的变量
		注意：在 Ruby 中，您可以通过在变量或常量前面放置 #{ expr } 字符，来访问任何变量或常量的值。

		a.局部变量：局部变量是在方法中定义的变量。局部变量在方法外是不可用的。局部变量以小写字母或 _ 开始。
		局部变量的作用域从 class、module、def 或 do 到相对应的结尾或者从左大括号到右大括号 {}。
	
		b.实例变量：实例变量可以跨任何特定的实例或对象中的方法使用。这意味着，实例变量可以从对象到对象的改变。实例变量在变量名之前放置符号（@）。
		未初始化的实例变量的值为 nil

	========================================================================	
		class Customer
		   def initialize(id, name, addr)
		      @cust_id=id
		      @cust_name=name
		      @cust_addr=addr
		   end
	   
		  def display_details()
		      puts "Customer id #{@cust_id}"
		      puts "Customer name #{@cust_name}"
		      puts "Customer address #{@cust_addr}"
		    end
		end
	========================================================================	

		c.类变量：类变量可以跨不同的对象使用。类变量属于类，且是类的一个属性。类变量在变量名之前放置符号（@@）。
		必须初始化后才能在方法定义中使用，类变量在定义它的类或模块的子类或子模块中可共享使用。
	
	========================================================================	
		class Customer
		   @@no_of_customers=0
		    def total_no_of_customers()
		       @@no_of_customers += 1
		       puts "Total number of customers: #{@@no_of_customers}"
		    end
		end
	=====================================================================

		d.全局变量：类变量不能跨类使用。如果您想要有一个可以跨类使用的变量，您需要定义全局变量。全局变量总是以美元符号（$）开始。
		未初始化的实例变量的值为 nil	
	
	=====================================================================
		$global_variable = 10
		class Class1
			  def print_global
			      puts "全局变量在 Class1 中输出为 #{$global_variable}"
			  end
		end

		class Class2
			  def print_global
			      puts "全局变量在 Class2 中输出为 #{$global_variable}"
			  end
		end
	 =====================================================================
	
		e.Ruby常量以大写字母开头。定义在类或模块内的常量可以从类或模块的内部访问，定义在类或模块外的常量可以被全局访问。

	======================================================================
		class Example
		   VAR1 = 100
		   VAR2 = 200
		   def show
		       puts "第一个常量的值为 #{VAR1}"
		       puts "第二个常量的值为 #{VAR2}"
		   end
		end
	=======================================================================
	

	(3)创建对象
		使用类的方法 new 创建对象。
		cust1 = Customer. new
		cust2 = Customer. new

		构造方法
		class Customer
			   @@no_of_customers=0
			   def initialize(id, name, addr)
			      @cust_id=id
			      @cust_name=name
		      	      @cust_addr=addr
			   end	
		end

	(4)Ruby 类中的成员函数
		类中的每个方法是以关键字 def 开始，方法名总是以小写字母开头
		
		class Sample
		   def function
		      statement 1
		      statement 2
		   end
		end
		
	
二.语句
	
	(1)if..else

	=====================================================================
		x=1
		if x > 2
		   puts "x 大于 2"
		elsif x <= 2 and x!=0
		   puts "x 是 1"
		else
		   puts "无法得知 x 的值"
		end
	=====================================================================
	
		$debug=1
		print "debug\n" if $debug
	
	=====================================================================

	
	(2)case
		
	=====================================================================
		$age =  5
		case $age
		when 0 .. 2
		    puts "婴儿"
		when 3 .. 6
		    puts "小孩"
		when 7 .. 12
		    puts "child"
		when 13 .. 18
		    puts "少年"
		else
		    puts "其他年龄段的"
		end
	=====================================================================

	(3)while
		
	=====================================================================
		$i = 0
		$num = 5
 
		while $i < $num  do
		   puts("在循环语句中 i = #$i" )
		   $i +=1
		end
	=====================================================================

		$i = 0
		$num = 5
		begin
		   puts("在循环语句中 i = #$i" )
		   $i +=1
		end while $i < $num
	=====================================================================
	
	(4)for
	
	=====================================================================
	for i in 0..5
	   puts "局部变量的值为 #{i}"
	end

	(0..5).each do |i|
	   puts "局部变量的值为 #{i}"
	end
	=====================================================================
	
	(5)break,next,redo

	=====================================================================
	for i in 0..5
	   if i > 2 then
	      break
	   end
	   puts "局部变量的值为 #{i}"
	end
	
	>局部变量的值为 0
	>局部变量的值为 1
	>局部变量的值为 2
	=====================================================================

	for i in 0..5
	   if i < 2 then
	      next
	   end
	   puts "局部变量的值为 #{i}"
	end
	
	>局部变量的值为 2
	>局部变量的值为 3
	>局部变量的值为 4
	>局部变量的值为 5

	=====================================================================

	for i in 0..5
	   if i < 2 then
	      puts "局部变量的值为 #{i}"
	      redo
	   end
	end	
	
	>局部变量的值为 0
	>局部变量的值为 0
	>...

三.ruby方法

	(1)简单的方法
	def method_name 
	   expr..
	end
	
	(2)接受参数的方法
	def method_name (var1, var2)
	   expr..
	end
	
	(3)参数设置默认值
	def method_name (var1=value1, var2=value2)
	   expr..
	end

	(4)调用方法
	method_name
	method_name 25, 30

	(6)return 语句
	def test
	   i = 100
	   j = 200
	   k = 300
	return i, j, k
	end
	var = test
	puts var
	
	>100
	>200
	>300

	(7)可变数量的参数
	
	def sample (*test)
	   puts "参数个数为 #{test.length}"
	   for i in 0...test.length
	      puts "参数值为 #{test[i]}"
	   end
	end
	sample "Zara", "6", "F"
	sample "Mac", "36", "M", "MCA"

	(8)alias 语句
	这个语句用于为方法或全局变量起别名。为编号的全局变量（$1, $2,...）起别名是被禁止的。
		
	alias 方法名 方法名
	alias 全局变量 全局变量
	
	(9)undef 语句
	这个语句用于取消方法定义。undef 不能出现在方法主体内。
	under bar

四.ruby块
	
	块总是从与其具有相同名称的函数调用。这意味着如果您的块名称为 test，那么您要使用函数 test 来调用这个块。您可以使用 yield 语句来调用块。

	=====================================================================
	def test
	   puts "在 test 方法内"
	   yield
	   puts "你又回到了 test 方法内"
	   yield
	end
	

	test {puts "你在块内"}
	>在 test 方法内
	>你在块内
	>你又回到了 test 方法内
	>你在块内
	=====================================================================

	传递带有参数的 yield 语句
	
	def test
	   yield 5
	   puts "在 test 方法内"
	   yield 100
	end
	
	test {|i| puts "你在块 #{i} 内"}
	>你在块 5 内
	>在 test 方法内
	>你在块 100 内
	=====================================================================

	在块中，您可以在两个竖线之间放置一个变量来接受参数。因此，在上面的代码中，yield 5 语句向 test 块传递值 5 作为参数。
	test {|i| puts "你在块 #{i} 内"}

	如果您想要传递多个参数，那么 yield 语句如下所示：
	yield a, b
	test {|a, b| statement}


五.ruby模块

	模块（Module）定义了一个命名空间，相当于一个沙盒，在里边您的方法和常量不会与其他地方的方法常量冲突。
	模块类似与类，但有一下不同：
		(1)模块不能实例化
		(2)模块没有子类
		(3)模块只能被另一个模块定义

	=====================================================================
	
	module Identifie
	   statement1
	   statement2
	   ...........
	end
	=====================================================================

	就像类方法，当您在模块中定义一个方法时，您可以指定在模块名称后跟着一个点号，点号后跟着方法名。

	module Trig
	   PI = 3.141592654
	   def Trig.sin(x)
	   # ..
	   end
	   def Trig.cos(x)
	   # ..
	   end
	end
	=====================================================================
	
	Ruby require 语句
	require 语句类似于 C 和 C++ 中的 include 语句以及 Java 中的 import 语句。如果一个第三方的程序想要使用任何已定义的模块，
	则可以简单地使用 Ruby require 语句来加载模块文件：
	
	$LOAD_PATH << '.'
 
	require 'trig.rb'
	require 'moral'

 	$LOAD_PATH << '.' 让 Ruby 知道必须在当前目录中搜索被引用的文件。如果您不想使用 $LOAD_PATH，那么您可以使用 require_relative 
	来从一个相对目录引用文件。
	
	=====================================================================
	Ruby include 语句
	您可以在类中嵌入模块。为了在类中嵌入模块，您可以在类中使用 include 语句：
	module Week
	  ....
	end
	
	class Decade
	include Week
	  ....
	end

	=====================================================================
	Ruby 中的 Mixins
	Ruby 没有真正实现多重继承机制，而是采用成为mixin技术作为替代品。将模块include到类定义中，模块中的方法就mix进了类中。
	
	module A
	   def a1
	   end
	   def a2
	   end
	end
	module B
	   def b1
	   end
	   def b2
	   end
	end
 
	class Sample
	include A
	include B
		def s1
	        end
	end
